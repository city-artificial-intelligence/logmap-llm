'''
This module contains functionality that supports bridging
between the worlds of Python and Java.
'''

#%% Python imports

import pandas as pd
from constants import EntityType, EntityRelation


#%% Java imports

# These import statements presume that JPype has been imported
# and used to start a JVM (Java Virtual Machine) that has
# LogMap (a Java application) in its classpath. If these 
# pre-conditions are satisfied, these import statements (that
# refer to Java packages and Java classes) will succeed even
# though PyLance cannot resolve them.
from uk.ac.ox.krr.logmap2.mappings.objects import MappingObjectStr
from java.util import HashSet


#%% Column names

column_source_entity_uri = 'source_entity_uri'
column_target_entity_uri = 'target_entity_uri'
column_relation = 'relation'
column_confidence = 'confidence'
column_entityType = 'entityType'


#%% Entity type representations

# LogMap recognises 5 entity types in its <MappingObjectStr> objects,
# each one represented by a particular integer. The LogMap m_ask 
# output file uses string representations for the 5 entity types.
# LogMap-LLM maps the LogMap integer entity types to the same string
# representations and uses these alone, internally (in memory) and
# externally in LogMap-LLM output files.

# map for int 2 str
entityType_int_2_str = {0: EntityType.CLASS.value,       
                        1: EntityType.DATAPROPERTY.value,
                        2: EntityType.OBJECTPROPERTY.value,
                        3: EntityType.INSTANCE.value,
                        4: EntityType.UNKNOWN.value}

# map for str 2 int
entityType_str_2_int = {et_str: et_int for et_int, et_str in entityType_int_2_str.items()}


#%% Relation representations

# LogMap recognises 3 relations in its <MappingObjectStr> objects,
# each one represented by a particular integer. The LogMap m_ask 
# output file uses string representations for the 3 relations.
# LogMap-LLM maps the LogMap integer relations to the same string
# representations and uses these alone, internally (in memory) and
# externally in LogMap-LLM output files.
#
#  0 - < - subClassOf    (src_entity subClassOf tgt_entity)  
# -1 - > - superClassOf  (src_entity superClassOf tgt_entity)
# -2 - = - equivalence   (src_entity equivalent tgt_entity)

# map for int 2 str
relation_int_2_str = { 0: EntityRelation.SUBCLASSOF.value,
                      -1: EntityRelation.SUPERCLASSOF.value,
                      -2: EntityRelation.EQUIVALENCE.value}

# map for str 2 int
relation_str_2_int = {r_str: r_int for r_int, r_str in relation_int_2_str.items()}


#%%

def java_mappings_2_python(m_ask_java):
    '''
    Convert a set of ontology alignment mappings from LogMap's Java 
    representation to LogMap-LLM's Python represention.

    Parameters
    ----------
    m_ask_java : java.util.HashSet of LogMap <MappingObjectStr> objects
        The mappings_to_ask an Oracle generated by LogMap

    Returns
    -------
    m_ask_df : Pandas DataFrame
        A dataframe representation of m_ask_java
    '''

    # convert java.util.HashSet to Object[] array
    m_ask_java = m_ask_java.toArray()

    # initialise containers for mapping elements
    src_entity_uris = []
    tgt_entity_uris = []
    relations = []
    confidences = []
    entityTypes = []

    # iterate over the mappings in their Java representation
    for mapping_java in m_ask_java:

        # get the URIs of the two entities
        src_entity_uris.append(str(mapping_java.getIRIStrEnt1()))
        tgt_entity_uris.append(str(mapping_java.getIRIStrEnt2()))

        # convert LogMap's integer representation of the entity 
        # relation to a string representation
        relation_int = mapping_java.getMappingDirection()
        if relation_int in relation_int_2_str:
            relation = relation_int_2_str[relation_int]
        else:
            raise ValueError(f'Relation {relation_int} not recognised')
        relations.append(relation)

        # get LogMap's confidence in the mapping
        confidences.append(mapping_java.getConfidence())

        # convert LogMap's integer representation of the entity type
        # to a string representation
        entityType_int = mapping_java.getTypeOfMapping()
        if entityType_int in entityType_int_2_str:
            entityType = entityType_int_2_str[entityType_int]
        else:
            raise ValueError(f'Entity type {entityType_int} not recognised')
        entityTypes.append(entityType)
    
    # assemble the columns of mapping elements into a DataFrame
    m_ask_df = pd.DataFrame(data={column_source_entity_uri: src_entity_uris,
                                  column_target_entity_uri: tgt_entity_uris,
                                  column_relation: relations,
                                  column_confidence: confidences,
                                  column_entityType: entityTypes})
    
    return m_ask_df


#%%

def get_m_ask_column_names():

  column_names = [
      column_source_entity_uri,
      column_target_entity_uri,
      column_relation,
      column_confidence,
      column_entityType
  ]

  return column_names


#%%

def python_oracle_mapping_predictions_2_java(m_ask_df_ext):
    '''
    Convert a set of Python LLM Oracle mapping predictions to a
    set of Java (LogMap) MappingObjectStr objects. 

    Note: In general, the LLM Oracle predictions will be a mix
    of True and False predictions. But LogMap expects to receive
    from an Oracle a set of True mappings only. So, in addition
    to converting between Python and Java datatypes, this
    function also *filters out* the mappings predicted to be False.

    Parameters
    ----------
    m_ask_df_ext : pandas DataFrame
        A Python representation of LogMap's m_ask output, extended with
        LLM Oracle predictions.

    Returns
    -------
    m_ask_oracle_preds_java : java.util.HashSet of LogMap <MappingObjectStr> objects
        The subset of the mappings in m_ask that an LLM Oracle predicted
        to be True mappings.
    '''

    # container for a collection of LogMap <MappingObjectStr> Java objects
    m_ask_oracle_preds_true = []

    # iterate over the DataFrame rows (Oracle mapping predictions) and
    # create a Python list of LogMap <MappingObjectStr> Java objects
    for row in m_ask_df_ext.itertuples():

        # skip over (i.e. filter-out) everything except mappings
        # with an Oracle prediction of True; this excludes mappings
        # with Oracle prediction values of False and 'error'
        if not row.Oracle_prediction == True:
            continue

        iri1 = row.source_entity_uri
        iri2 = row.target_entity_uri
        conf = row.Oracle_confidence

        # for the relation, get the integer representation
        # recognised by LogMap
        if row.relation in relation_str_2_int:
            relation_int = relation_str_2_int[row.relation]
        else:
            raise ValueError(f'Entity relation {row.relation} not recognised')
        
        # for the entityType, get the integer representation
        # recognised by LogMap
        if row.entityType in entityType_str_2_int:
            entityType_int = entityType_str_2_int[row.entityType]
        else:
            raise ValueError(f'Entity type {row.entityType} not recognised')

        mos = MappingObjectStr(iri1, iri2, conf, relation_int, entityType_int)

        m_ask_oracle_preds_true.append(mos)
    
    # convert the Python list of <MappingObjectStr> Java objects to a
    # java.util.HashSet of <MappingObjectStr> Java objects
    m_ask_oracle_preds_java = HashSet(m_ask_oracle_preds_true)

    return m_ask_oracle_preds_java

